# Authors: Code generated by Google Gemini (based on downloaded generate outline code for answer set programming)
# and comments done by Daniel Holgate
# Date: 16/09/2025
# Description: Code for running an LP file to generate answer set programming story outlines.

# Uses clingo to run the answer set programming outline generation.
from clingo.control import Control
import random

# Input LP file and output file.
# Change to file want to save outlines to.
OUTPUT_FILE = ""
# Change to name of file generated by GenerateLPFunction.py.
LP_FILE = ""

# Method for generating random outlines.
def generate_random_outlines():
    # Specifies how many outlines to generate. This you can change for your circumstances.
    num_outlines = 10000
    outlines_file = open(OUTPUT_FILE, "w")
    all_outlines = []

    # Method for taking all the generated outlines and writing them to the output file.
    def collect_outline(model):
        syms = model.symbols(shown=True)
        scene_info = {}

        # Goes through the symbols (actions) in the model and populates them with actual functions from the lp file.
        for sym in syms:
            if sym.name == "scene_performs_function":
                scene_index = sym.arguments[0].number
                function_name = sym.arguments[1].name
                scene_info.setdefault(scene_index, []).append(function_name)
            elif sym.name == "scene_introduce_personality":
                scene_index = sym.arguments[0].number
                personality = sym.arguments[1].name
                scene_info.setdefault(scene_index, []).append(personality)
            elif sym.name == "scene_define_obstacle_type":
                scene_index = sym.arguments[0].number
                obstacle_type = sym.arguments[1].name
                scene_info.setdefault(scene_index, []).append(obstacle_type)

        outline = []
        # Turns the populated model entries into the final outline.
        for scene_index in sorted(scene_info.keys()):
            elements = scene_info[scene_index]
            if len(elements) > 1:
                outline.append(f"{elements[0]}:{elements[1]}")
            else:
                outline.append(elements[0])

        all_outlines.append(outline)
        outlines_file.write(",".join(outline) + "\n")
        # print(f"Generated Outline: {outline}")

    for i in range(num_outlines):
        # Selects random seed to try get as much variety in outlines as possible.
        seed = random.randint(0, 100000)
        # print(f"\n--- Generating outline {i + 1} with seed {seed} ---")
        # ctl = Control()
        # Control allows interacting with and using clingo. Rand freq tells it to randomly pick between possibilities
        # if there is no rule specifying what to select, seed sets a random seed (if did the same seed would get the same outlines)
        # and models specifies how many models (pre-outlines) to send at a time.
        ctl = Control(["--rand-freq=1.0", f"--seed={seed}", "--models=1"])
        ctl.load(f"./{LP_FILE}")
        # Replaces all variables in the rules (earlier in the method) with all possible choices.
        ctl.ground()
        # Each time  a valid answer set model (that needs to be converted into an outline), it calls collect outline to add it to 
        # the set of generated outlines.
        ctl.solve(on_model=collect_outline, on_unsat=lambda: print("No outline found (UNSAT)."))

    outlines_file.close()
    print(f"\nTotal randomized outlines generated: {len(all_outlines)}")
    return all_outlines

generate_random_outlines()